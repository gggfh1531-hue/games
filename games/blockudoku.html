<!DOCTYPE html>
<html lang="ar">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Blockudoku Clean Edition (Fade + Hint + GameOver)</title>
<style>
  body{
    margin:0;
    background:#e8edf3;
    display:flex;
    justify-content:center;
    align-items:center;
    height:100vh;
    overflow:hidden;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
  }

  #ui{
    position:absolute;
    top:34px;
    text-align:center;
    width:100%;
    pointer-events:none;
    user-select:none;
  }

  /* ✅ أزرار التحكم */
  #buttons{
    position:fixed;
    top:18px;
    left:18px;
    display:flex;
    gap:10px;
    z-index:20;
    pointer-events:auto;
  }
  .btnTop{
    appearance:none;
    border:0;
    background:rgba(255,255,255,0.85);
    color:#1f4fb6;
    font-weight:900;
    padding:10px 14px;
    border-radius:999px;
    font-size:14px;
    cursor:pointer;
    box-shadow:0 10px 25px rgba(0,0,0,0.12);
    backdrop-filter: blur(8px);
  }
  .btnTop:disabled{
    opacity:0.45;
    cursor:not-allowed;
  }

  #score{
    font-size:54px;
    font-weight:900;
    letter-spacing:1px;
    color:#1f4fb6;
    line-height:1;
  }
  #best{
    margin-top:10px;
    font-size:16px;
    font-weight:700;
    color:rgba(31,79,182,0.55);
  }

  canvas{ touch-action:none; }

  /* Game over overlay */
  #over{
    position:fixed; inset:0;
    display:none;
    justify-content:center; align-items:center;
    background:rgba(10,12,15,0.45);
    z-index:10;
  }
  #card{
    width:min(360px, 84vw);
    background:#ffffff;
    border-radius:18px;
    padding:18px 18px 16px;
    box-shadow:0 22px 60px rgba(0,0,0,0.22);
    text-align:center;
  }
  #card h2{
    margin:4px 0 10px;
    font-size:26px;
    color:#12203b;
  }
  #final{
    font-size:18px;
    color:#223a6e;
    font-weight:800;
    margin-bottom:14px;
  }
  #again{
    pointer-events:auto;
    appearance:none;
    border:0;
    background:#1f4fb6;
    color:#fff;
    font-weight:900;
    padding:12px 18px;
    border-radius:999px;
    font-size:16px;
    cursor:pointer;
  }
</style>
</head>
<body>

<!-- ✅ زر الرئيسية + تراجع -->
<div id="buttons">
  <button id="homeBtn" class="btnTop">الرئيسية</button>
  <button id="undoBtn" class="btnTop" disabled>تراجع</button>
</div>

<div id="ui">
  <div id="score">0</div>
  <div id="best">Best: 0</div>
</div>

<canvas id="game"></canvas>

<div id="over">
  <div id="card">
    <h2>انتهت اللعبة</h2>
    <div id="final">Score: 0</div>
    <button id="again">إعادة</button>
  </div>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const GRID = 9;

// 0 = empty, 1 = filled, 2 = clearing (fade)
let board = Array.from({length: GRID}, () => Array(GRID).fill(0));
let clearA = Array.from({length: GRID}, () => Array(GRID).fill(0));

let score = 0;
let best = Number(localStorage.getItem("bd_best") || 0);

let tray = [], dragging = null, ghost = null; // ghost: {gr,gc, ok, willClear, clearSet}
let gameOver = false;

const CLEAR_MS = 280;

// ✅ لون المكعبات
const COLORS = {
  bg: "#e8edf3",
  cell1: "#ffffff",
  cell2: "#f2f5fa",
  gridLine: "rgba(160,170,185,0.55)",
  gridBold: "rgba(140,150,165,0.75)",

  block: "#2B63D9",
  blockHint: "#9DCCFF",

  panelTop: "#f7f9fc",
  panelBot: "#e9eef6",
  panelBorder: "rgba(150,160,175,0.60)",
  panelInner: "rgba(255,255,255,0.75)",
};

// ✅ قوة التنبيه (فاتح جدًا)
const HINT_ALPHA_CELL = 0.85;
const HINT_ALPHA_GHOST = 0.55;

// ---------- UI ----------
const scoreEl = document.getElementById("score");
const bestEl = document.getElementById("best");
const overEl = document.getElementById("over");
const finalEl = document.getElementById("final");

const homeBtn = document.getElementById("homeBtn");
const undoBtn = document.getElementById("undoBtn");

homeBtn.onclick = () => {
  // يرجع لقائمة الألعاب (تأكد اسم الصفحة عندك index.html)
  window.location.href = "index.html";
};

document.getElementById("again").onclick = () => reset();

function setScore(v){
  score = v;
  scoreEl.textContent = score;
  if(score > best){
    best = score;
    localStorage.setItem("bd_best", String(best));
  }
  bestEl.textContent = "Best: " + best;
}
setScore(0);
bestEl.textContent = "Best: " + best;

// ---------- ✅ Undo (مرة وحدة فقط) ----------
let undoState = null; // snapshot
function deepCopyBoard(b){ return b.map(row => row.slice()); }
function deepCopyTray(t){
  return t.map(p => ({
    cells: p.cells.map(([r,c])=>[r,c]),
    used: p.used,
    x: p.x, y: p.y, dragging: false,
    rx: p.rx, ry: p.ry,
    offX: p.offX, offY: p.offY
  }));
}
function saveUndoSnapshot(){
  undoState = {
    board: deepCopyBoard(board),
    clearA: deepCopyBoard(clearA),
    score: score,
    tray: deepCopyTray(tray),
    gameOver: gameOver
  };
  undoBtn.disabled = false;
}
function restoreUndo(){
  if(!undoState) return;
  board = deepCopyBoard(undoState.board);
  clearA = deepCopyBoard(undoState.clearA);
  tray = deepCopyTray(undoState.tray);
  setScore(undoState.score);

  gameOver = false;
  hideGameOver();

  dragging = null;
  ghost = null;

  // تراجع مرة وحدة فقط
  undoState = null;
  undoBtn.disabled = true;
}
undoBtn.onclick = () => {
  if(gameOver) hideGameOver();
  restoreUndo();
};

// ---------- DPR / resize ----------
function resize(){
  const dpr = window.devicePixelRatio || 1;
  canvas.style.width = window.innerWidth + "px";
  canvas.style.height = window.innerHeight + "px";
  canvas.width = Math.floor(window.innerWidth * dpr);
  canvas.height = Math.floor(window.innerHeight * dpr);
  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(dpr, dpr);
}
window.addEventListener("resize", resize);
resize();

// ---------- shapes ----------
const BASE_SHAPES = [
  [[0,0]],

  [[0,0],[0,1]],
  [[0,0],[1,0]],

  [[0,0],[0,1],[0,2]],
  [[0,0],[1,0],[2,0]],

  [[0,0],[0,1],[0,2],[0,3]],
  [[0,0],[1,0],[2,0],[3,0]],

  [[0,0],[0,1],[1,0],[1,1]],

  [[0,0],[0,1],[0,2],[1,1]],

  [[0,0],[0,1],[0,2],[1,1],[2,1]],

  [[0,0],[1,0],[2,0],[2,1],[2,2]],

  [[0,0],[1,0],[1,1],[1,2]],
  [[0,0],[0,1],[0,2],[1,0]],

  [[0,0],[0,1],[1,1],[1,2]],

  [[0,0],[1,0],[1,1]],
];

function norm(shape){
  let minR = 999, minC = 999;
  for(const [r,c] of shape){ if(r<minR) minR=r; if(c<minC) minC=c; }
  const s = shape.map(([r,c])=>[r-minR,c-minC]).sort((a,b)=>a[0]-b[0] || a[1]-b[1]);
  return s;
}
function keyOf(shape){ return shape.map(([r,c])=>r+":"+c).join("|"); }
function rotate90(shape){
  const rot = shape.map(([r,c])=>[c,-r]);
  return norm(rot);
}
function mirrorX(shape){
  const mir = shape.map(([r,c])=>[r,-c]);
  return norm(mir);
}
function genVariants(base){
  const out = new Map();
  let s = norm(base);
  for(let i=0;i<4;i++){
    out.set(keyOf(s), s);
    const mx = mirrorX(s);
    out.set(keyOf(mx), mx);
    s = rotate90(s);
  }
  return [...out.values()];
}
const SHAPES = BASE_SHAPES.flatMap(genVariants);

// ---------- tray ----------
function pickRandomShape(){
  return SHAPES[(Math.random()*SHAPES.length)|0];
}
function newTray(){
  tray = [0,1,2].map(() => ({
    cells: pickRandomShape(),
    used:false,
    x:0, y:0, dragging:false,
    rx:0, ry:0, offX:0, offY:0
  }));
}
newTray();

// ---------- geometry / panel ----------
function roundRectPath(x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}
function drawPanel(px, py, pw, ph){
  ctx.save();
  ctx.shadowColor = "rgba(0,0,0,0.18)";
  ctx.shadowBlur = 18;
  ctx.shadowOffsetY = 10;

  const grad = ctx.createLinearGradient(px, py, px, py+ph);
  grad.addColorStop(0, COLORS.panelTop);
  grad.addColorStop(1, COLORS.panelBot);

  ctx.fillStyle = grad;
  roundRectPath(px, py, pw, ph, 18);
  ctx.fill();
  ctx.restore();

  ctx.lineWidth = 2;
  ctx.strokeStyle = COLORS.panelBorder;
  roundRectPath(px, py, pw, ph, 18);
  ctx.stroke();

  ctx.lineWidth = 2;
  ctx.strokeStyle = COLORS.panelInner;
  roundRectPath(px+6, py+6, pw-12, ph-12, 14);
  ctx.stroke();
}

function drawBlock(x, y, s, color, alpha=1, fadeScale=1){
  ctx.save();
  ctx.globalAlpha = alpha;

  const cx = x + s/2, cy = y + s/2;
  const ss = s * fadeScale;
  const xx = cx - ss/2, yy = cy - ss/2;

  ctx.shadowColor = "rgba(0,0,0,0.18)";
  ctx.shadowBlur = Math.max(6, ss * 0.10);
  ctx.shadowOffsetY = Math.max(1, ss * 0.03);

  ctx.fillStyle = color;
  ctx.fillRect(xx, yy, ss, ss);

  ctx.restore();
}

// ---------- logic ----------
function canPlace(p, gr, gc){
  for(const [dr,dc] of p.cells){
    const r = gr+dr, c = gc+dc;
    if(r<0 || r>=GRID || c<0 || c>=GRID) return false;
    if(board[r][c] !== 0) return false;
  }
  return true;
}

function getClearSetIfPlaced(p, gr, gc){
  const add = new Set();
  for(const [dr,dc] of p.cells){
    add.add((gr+dr)+","+ (gc+dc));
  }
  const isFilled = (r,c) => {
    if(add.has(r+","+c)) return true;
    return board[r][c] === 1;
  };

  const toDel = new Set();

  for(let r=0;r<GRID;r++){
    let full = true;
    for(let c=0;c<GRID;c++){
      if(!isFilled(r,c)) { full=false; break; }
    }
    if(full) for(let c=0;c<GRID;c++) toDel.add(r+","+c);
  }

  for(let c=0;c<GRID;c++){
    let full = true;
    for(let r=0;r<GRID;r++){
      if(!isFilled(r,c)) { full=false; break; }
    }
    if(full) for(let r=0;r<GRID;r++) toDel.add(r+","+c);
  }

  for(let br=0;br<GRID;br+=3){
    for(let bc=0;bc<GRID;bc+=3){
      let full = true;
      for(let r=0;r<3;r++){
        for(let c=0;c<3;c++){
          if(!isFilled(br+r, bc+c)) { full=false; break; }
        }
        if(!full) break;
      }
      if(full){
        for(let r=0;r<3;r++){
          for(let c=0;c<3;c++){
            toDel.add((br+r)+","+(bc+c));
          }
        }
      }
    }
  }
  return toDel;
}

function checkLines(){
  let toDel = new Set();

  for(let r=0; r<GRID; r++){
    let full = true;
    for(let c=0;c<GRID;c++){
      if(board[r][c] !== 1) { full=false; break; }
    }
    if(full) for(let c=0;c<GRID;c++) toDel.add(r+","+c);
  }

  for(let c=0; c<GRID; c++){
    let full = true;
    for(let r=0;r<GRID;r++){
      if(board[r][c] !== 1) { full=false; break; }
    }
    if(full) for(let r=0;r<GRID;r++) toDel.add(r+","+c);
  }

  for(let br=0;br<GRID;br+=3){
    for(let bc=0;bc<GRID;bc+=3){
      let full = true;
      for(let r=0;r<3;r++){
        for(let c=0;c<3;c++){
          if(board[br+r][bc+c] !== 1) { full=false; break; }
        }
        if(!full) break;
      }
      if(full){
        for(let r=0;r<3;r++) for(let c=0;c<3;c++) toDel.add((br+r)+","+(bc+c));
      }
    }
  }

  if(toDel.size){
    setScore(score + toDel.size);
    for(const k of toDel){
      const [r,c] = k.split(",").map(Number);
      if(board[r][c] === 1){
        board[r][c] = 2;
        clearA[r][c] = 1;
      }
    }
  }
}

function stepFades(dt){
  const d = dt / CLEAR_MS;
  for(let r=0;r<GRID;r++){
    for(let c=0;c<GRID;c++){
      if(board[r][c] === 2){
        clearA[r][c] -= d;
        if(clearA[r][c] <= 0){
          clearA[r][c] = 0;
          board[r][c] = 0;
        }
      }
    }
  }
}

function anyMovesLeft(){
  const pieces = tray.filter(p => !p.used);
  if(pieces.length === 0) return true;

  for(const p of pieces){
    for(let gr=0; gr<GRID; gr++){
      for(let gc=0; gc<GRID; gc++){
        if(canPlace(p, gr, gc)) return true;
      }
    }
  }
  return false;
}

function showGameOver(){
  gameOver = true;
  finalEl.textContent = "Score: " + score;
  overEl.style.display = "flex";
}
function hideGameOver(){
  overEl.style.display = "none";
}

function reset(){
  board = Array.from({length: GRID}, () => Array(GRID).fill(0));
  clearA = Array.from({length: GRID}, () => Array(GRID).fill(0));
  setScore(0);
  dragging = null;
  ghost = null;
  gameOver = false;
  hideGameOver();
  newTray();

  // reset undo
  undoState = null;
  undoBtn.disabled = true;
}

// ---------- render ----------
let lastTs = 0;
function draw(ts){
  if(!lastTs) lastTs = ts;
  const dt = Math.min(40, ts - lastTs);
  lastTs = ts;

  stepFades(dt);

  ctx.fillStyle = COLORS.bg;
  ctx.fillRect(0,0,window.innerWidth, window.innerHeight);

  const boardSize = Math.min(window.innerWidth * 0.94, 520);
  const cell = boardSize / GRID;
  const bx = (window.innerWidth - boardSize) / 2;
  const by = 125;

  const pad = Math.max(14, cell*0.22);
  drawPanel(bx - pad, by - pad, boardSize + pad*2, boardSize + pad*2);

  for(let r=0;r<GRID;r++){
    for(let c=0;c<GRID;c++){
      const alt = (Math.floor(r/3) + Math.floor(c/3)) % 2;
      ctx.fillStyle = alt ? COLORS.cell2 : COLORS.cell1;
      ctx.fillRect(bx + c*cell, by + r*cell, cell, cell);

      const v = board[r][c];
      if(v === 1){
        drawBlock(bx + c*cell, by + r*cell, cell, COLORS.block, 1, 1);
      }else if(v === 2){
        const a = Math.max(0, clearA[r][c]);
        const sc = 0.92 + a*0.08;
        drawBlock(bx + c*cell, by + r*cell, cell, COLORS.block, a, sc);
      }
    }
  }

  ctx.lineWidth = 1;
  ctx.strokeStyle = COLORS.gridLine;
  for(let i=0; i<=GRID; i++){
    const x = bx + i*cell;
    const y = by + i*cell;
    ctx.beginPath(); ctx.moveTo(x, by); ctx.lineTo(x, by+boardSize); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(bx, y); ctx.lineTo(bx+boardSize, y); ctx.stroke();
  }
  ctx.lineWidth = 2;
  ctx.strokeStyle = COLORS.gridBold;
  for(let i=0;i<=GRID;i+=3){
    const x = bx + i*cell;
    const y = by + i*cell;
    ctx.beginPath(); ctx.moveTo(x, by); ctx.lineTo(x, by+boardSize); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(bx, y); ctx.lineTo(bx+boardSize, y); ctx.stroke();
  }

  // ✅ تنبيه كامل (صف/عمود/مربع) + ghost
  if(ghost && dragging && ghost.ok){
    if(ghost.clearSet && ghost.clearSet.size){
      for(const k of ghost.clearSet){
        const [r,c] = k.split(",").map(Number);
        drawBlock(bx + c*cell, by + r*cell, cell, COLORS.blockHint, HINT_ALPHA_CELL, 1);
      }
    }

    const gColor = ghost.willClear ? COLORS.blockHint : COLORS.block;
    const alpha = ghost.willClear ? HINT_ALPHA_GHOST : 0.28;
    for(const [dr,dc] of dragging.cells){
      drawBlock(
        bx + (ghost.gc+dc)*cell,
        by + (ghost.gr+dr)*cell,
        cell,
        gColor,
        alpha,
        1
      );
    }
  }

  const trayY = by + boardSize + 70;
  tray.forEach((p,i)=>{
    if(p.used) return;

    const s = p.dragging ? cell : cell * 0.62;
    const x = p.dragging ? p.x : (bx + i*(boardSize/3) + boardSize/6 - (s*1.5)/2);
    const y = p.dragging ? p.y : trayY;

    p.rx = x; p.ry = y;

    let drawColor = COLORS.block;
    if(p.dragging && ghost && ghost.ok && ghost.willClear) drawColor = COLORS.blockHint;

    for(const [dr,dc] of p.cells){
      drawBlock(x + dc*s, y + dr*s, s, drawColor, 1, 1);
    }
  });

  requestAnimationFrame(draw);
}

// ---------- input ----------
canvas.onpointerdown = e => {
  if(gameOver){
    reset();
    return;
  }

  const mx = e.clientX, my = e.clientY;
  canvas.setPointerCapture?.(e.pointerId);

  for(const p of tray){
    if(p.used) continue;
    const hitW = 150, hitH = 150;
    if(mx > p.rx-20 && mx < p.rx + hitW && my > p.ry-20 && my < p.ry + hitH){
      dragging = p;
      p.dragging = true;

      p.offX = mx - p.rx;
      p.offY = my - p.ry + 110;
      p.x = p.rx;
      p.y = p.ry;

      ghost = null;
      break;
    }
  }
};

canvas.onpointermove = e => {
  if(!dragging) return;

  const mx = e.clientX, my = e.clientY;
  dragging.x = mx - dragging.offX;
  dragging.y = my - dragging.offY;

  const boardSize = Math.min(window.innerWidth * 0.94, 520);
  const cell = boardSize / GRID;
  const bx = (window.innerWidth - boardSize) / 2;
  const by = 125;

  const gc = Math.round((dragging.x - bx) / cell);
  const gr = Math.round((dragging.y - by) / cell);

  const ok = canPlace(dragging, gr, gc);

  if(ok){
    const clearSet = getClearSetIfPlaced(dragging, gr, gc);
    const willClear = clearSet.size > 0;
    ghost = { gr, gc, ok:true, willClear, clearSet };
  }else{
    ghost = null;
  }
};

canvas.onpointerup = () => {
  if(!dragging) return;

  if(ghost && ghost.ok){
    // ✅ احفظ التراجع قبل أي تغيير
    saveUndoSnapshot();

    for(const [dr,dc] of dragging.cells){
      board[ghost.gr+dr][ghost.gc+dc] = 1;
    }
    dragging.used = true;

    setScore(score + dragging.cells.length);

    checkLines();

    if(tray.every(p => p.used)) newTray();

    if(!anyMovesLeft()){
      showGameOver();
    }
  }

  dragging.dragging = false;
  dragging = null;
  ghost = null;
};

// start
requestAnimationFrame(draw);
</script>
</body>
</html>
